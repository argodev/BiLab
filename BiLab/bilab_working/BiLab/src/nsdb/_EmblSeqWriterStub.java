package nsdb;


/**
* nsdb/_EmblSeqWriterStub.java .
* Generated by the IDL-to-Java compiler (portable), version "3.1"
* from corba/nsdb_write.idl
* Tuesday, March 7, 2006 12:49:18 PM GMT
*/

public class _EmblSeqWriterStub extends org.omg.CORBA.portable.ObjectImpl implements nsdb.EmblSeqWriter
{


  /**
       * Create a new feature in this EmblSeq object.
       * @parm key Type of the feature to be created
       * @parm location_string The location of the new NucFeature
       * @raises LocationParse If the location string is not a valid location.
       * @raises type::IndexOutOfRange If any part of the location is beyond the
       *   end of the sequence
       * @raises InvalidKey if the given key is not a possible EMBL key.
       */
  public nsdb.NucFeatureWriter createNucFeature (String key, String location) throws nsdb.LocationParse, type.IndexOutOfRange, nsdb.InvalidKey, nsdb.ReadOnlyException
  {
            org.omg.CORBA.portable.InputStream $in = null;
            try {
                org.omg.CORBA.portable.OutputStream $out = _request ("createNucFeature", true);
                $out.write_string (key);
                $out.write_string (location);
                $in = _invoke ($out);
                nsdb.NucFeatureWriter $result = nsdb.NucFeatureWriterHelper.read ($in);
                return $result;
            } catch (org.omg.CORBA.portable.ApplicationException $ex) {
                $in = $ex.getInputStream ();
                String _id = $ex.getId ();
                if (_id.equals ("IDL:nsdb/LocationParse:1.0"))
                    throw nsdb.LocationParseHelper.read ($in);
                else if (_id.equals ("IDL:type/IndexOutOfRange:1.0"))
                    throw type.IndexOutOfRangeHelper.read ($in);
                else if (_id.equals ("IDL:nsdb/InvalidKey:1.0"))
                    throw nsdb.InvalidKeyHelper.read ($in);
                else if (_id.equals ("IDL:nsdb/ReadOnlyException:1.0"))
                    throw nsdb.ReadOnlyExceptionHelper.read ($in);
                else
                    throw new org.omg.CORBA.MARSHAL (_id);
            } catch (org.omg.CORBA.portable.RemarshalException $rm) {
                return createNucFeature (key, location        );
            } finally {
                _releaseReply ($in);
            }
  } // createNucFeature


  /**
       * Remove the given feature.
       */
  public void remove (nsdb.NucFeature nuc_feature) throws nsdb.ReadOnlyException
  {
            org.omg.CORBA.portable.InputStream $in = null;
            try {
                org.omg.CORBA.portable.OutputStream $out = _request ("remove", true);
                nsdb.NucFeatureHelper.write ($out, nuc_feature);
                $in = _invoke ($out);
                return;
            } catch (org.omg.CORBA.portable.ApplicationException $ex) {
                $in = $ex.getInputStream ();
                String _id = $ex.getId ();
                if (_id.equals ("IDL:nsdb/ReadOnlyException:1.0"))
                    throw nsdb.ReadOnlyExceptionHelper.read ($in);
                else
                    throw new org.omg.CORBA.MARSHAL (_id);
            } catch (org.omg.CORBA.portable.RemarshalException $rm) {
                remove (nuc_feature        );
            } finally {
                _releaseReply ($in);
            }
  } // remove


  /**
       * retrieve sequence of NucFeatureList associated with
       * the nucleotide sequence that are within the given range of bases.
       * @raises type::NoResult if no features are owned by the sequence
       * @raises type::IndexOutOfRange if either of start_base or end_base is
       *  less than 1 or greater than the length of the sequence.
       */
  public nsdb.NucFeature[] getNucFeaturesInRange (int start_base, int end_base) throws type.NoResult, type.IndexOutOfRange
  {
            org.omg.CORBA.portable.InputStream $in = null;
            try {
                org.omg.CORBA.portable.OutputStream $out = _request ("getNucFeaturesInRange", true);
                $out.write_long (start_base);
                $out.write_long (end_base);
                $in = _invoke ($out);
                nsdb.NucFeature $result[] = nsdb.NucFeatureListHelper.read ($in);
                return $result;
            } catch (org.omg.CORBA.portable.ApplicationException $ex) {
                $in = $ex.getInputStream ();
                String _id = $ex.getId ();
                if (_id.equals ("IDL:type/NoResult:1.0"))
                    throw type.NoResultHelper.read ($in);
                else if (_id.equals ("IDL:type/IndexOutOfRange:1.0"))
                    throw type.IndexOutOfRangeHelper.read ($in);
                else
                    throw new org.omg.CORBA.MARSHAL (_id);
            } catch (org.omg.CORBA.portable.RemarshalException $rm) {
                return getNucFeaturesInRange (start_base, end_base        );
            } finally {
                _releaseReply ($in);
            }
  } // getNucFeaturesInRange


  /**
       *  Return the number of features
       */
  public int getNucFeatureCount ()
  {
            org.omg.CORBA.portable.InputStream $in = null;
            try {
                org.omg.CORBA.portable.OutputStream $out = _request ("getNucFeatureCount", true);
                $in = _invoke ($out);
                int $result = $in.read_long ();
                return $result;
            } catch (org.omg.CORBA.portable.ApplicationException $ex) {
                $in = $ex.getInputStream ();
                String _id = $ex.getId ();
                throw new org.omg.CORBA.MARSHAL (_id);
            } catch (org.omg.CORBA.portable.RemarshalException $rm) {
                return getNucFeatureCount (        );
            } finally {
                _releaseReply ($in);
            }
  } // getNucFeatureCount


  /**
       * Return the ith NucFeature from this Entry.  The feature are returned in
       * a consistent order, sorted by the first base of each Feature.
       * @raises type::IndexOutOfRange if the index is less than 0 or greater
       *   than the number of features.
       **/
  public nsdb.NucFeature getFeatureAtIndex (int i) throws type.IndexOutOfRange
  {
            org.omg.CORBA.portable.InputStream $in = null;
            try {
                org.omg.CORBA.portable.OutputStream $out = _request ("getFeatureAtIndex", true);
                $out.write_long (i);
                $in = _invoke ($out);
                nsdb.NucFeature $result = nsdb.NucFeatureHelper.read ($in);
                return $result;
            } catch (org.omg.CORBA.portable.ApplicationException $ex) {
                $in = $ex.getInputStream ();
                String _id = $ex.getId ();
                if (_id.equals ("IDL:type/IndexOutOfRange:1.0"))
                    throw type.IndexOutOfRangeHelper.read ($in);
                else
                    throw new org.omg.CORBA.MARSHAL (_id);
            } catch (org.omg.CORBA.portable.RemarshalException $rm) {
                return getFeatureAtIndex (i        );
            } finally {
                _releaseReply ($in);
            }
  } // getFeatureAtIndex


  /**
       * Return the index of the given Feature.  This does the reverse of
       * getFeatureAtIndex ().  Returns -1 if the given NucFeature is not in
       * this EmblSeq object.
       **/
  public int indexOf (nsdb.NucFeature feature)
  {
            org.omg.CORBA.portable.InputStream $in = null;
            try {
                org.omg.CORBA.portable.OutputStream $out = _request ("indexOf", true);
                nsdb.NucFeatureHelper.write ($out, feature);
                $in = _invoke ($out);
                int $result = $in.read_long ();
                return $result;
            } catch (org.omg.CORBA.portable.ApplicationException $ex) {
                $in = $ex.getInputStream ();
                String _id = $ex.getId ();
                throw new org.omg.CORBA.MARSHAL (_id);
            } catch (org.omg.CORBA.portable.RemarshalException $rm) {
                return indexOf (feature        );
            } finally {
                _releaseReply ($in);
            }
  } // indexOf


  /**
       *  commit any pending changes to the database immediately.
       */
  public void commit () throws nsdb.CommitFailed
  {
            org.omg.CORBA.portable.InputStream $in = null;
            try {
                org.omg.CORBA.portable.OutputStream $out = _request ("commit", true);
                $in = _invoke ($out);
                return;
            } catch (org.omg.CORBA.portable.ApplicationException $ex) {
                $in = $ex.getInputStream ();
                String _id = $ex.getId ();
                if (_id.equals ("IDL:nsdb/CommitFailed:1.0"))
                    throw nsdb.CommitFailedHelper.read ($in);
                else
                    throw new org.omg.CORBA.MARSHAL (_id);
            } catch (org.omg.CORBA.portable.RemarshalException $rm) {
                commit (        );
            } finally {
                _releaseReply ($in);
            }
  } // commit


  /**
       * Return a Datestamp that will be passed to the set methods on the
       * EmblSeqWriter methods and NucFeatureWriter methods.  The object that is
       * returned represents the time when the entry was last changed (the last
       * time a feature was added, removed or changed location).
       */
  public nsdb.Datestamp getDatestamp ()
  {
            org.omg.CORBA.portable.InputStream $in = null;
            try {
                org.omg.CORBA.portable.OutputStream $out = _request ("getDatestamp", true);
                $in = _invoke ($out);
                nsdb.Datestamp $result = nsdb.DatestampHelper.read ($in);
                return $result;
            } catch (org.omg.CORBA.portable.ApplicationException $ex) {
                $in = $ex.getInputStream ();
                String _id = $ex.getId ();
                throw new org.omg.CORBA.MARSHAL (_id);
            } catch (org.omg.CORBA.portable.RemarshalException $rm) {
                return getDatestamp (        );
            } finally {
                _releaseReply ($in);
            }
  } // getDatestamp


  /**
     * retrieve string representation of nucleotide sequence. Each character
     * in the string is a 
     *   <href="http://www.ebi.ac.uk/ebi_docs/embl_db/ft/iupac_codes.html">
     *   IUPAC nucleotide base code</A>
     * <P>
     * This method can be used instead of the getAnySeq() 
     * method in seqdb::BioSeq
     * @see seqdb::BioSeq
     */
  public String getSeq ()
  {
            org.omg.CORBA.portable.InputStream $in = null;
            try {
                org.omg.CORBA.portable.OutputStream $out = _request ("getSeq", true);
                $in = _invoke ($out);
                String $result = $in.read_string ();
                return $result;
            } catch (org.omg.CORBA.portable.ApplicationException $ex) {
                $in = $ex.getInputStream ();
                String _id = $ex.getId ();
                throw new org.omg.CORBA.MARSHAL (_id);
            } catch (org.omg.CORBA.portable.RemarshalException $rm) {
                return getSeq (        );
            } finally {
                _releaseReply ($in);
            }
  } // getSeq


  /**
     * Checksum on sequence to allow validation.
     * 
     */
  public int getCheckSum ()
  {
            org.omg.CORBA.portable.InputStream $in = null;
            try {
                org.omg.CORBA.portable.OutputStream $out = _request ("getCheckSum", true);
                $in = _invoke ($out);
                int $result = $in.read_ulong ();
                return $result;
            } catch (org.omg.CORBA.portable.ApplicationException $ex) {
                $in = $ex.getInputStream ();
                String _id = $ex.getId ();
                throw new org.omg.CORBA.MARSHAL (_id);
            } catch (org.omg.CORBA.portable.RemarshalException $rm) {
                return getCheckSum (        );
            } finally {
                _releaseReply ($in);
            }
  } // getCheckSum


  /**
     * topology of the nucleotide sequence
     * @see meta::nsdb
     */
  public String getTopology ()
  {
            org.omg.CORBA.portable.InputStream $in = null;
            try {
                org.omg.CORBA.portable.OutputStream $out = _request ("getTopology", true);
                $in = _invoke ($out);
                String $result = $in.read_string ();
                return $result;
            } catch (org.omg.CORBA.portable.ApplicationException $ex) {
                $in = $ex.getInputStream ();
                String _id = $ex.getId ();
                throw new org.omg.CORBA.MARSHAL (_id);
            } catch (org.omg.CORBA.portable.RemarshalException $rm) {
                return getTopology (        );
            } finally {
                _releaseReply ($in);
            }
  } // getTopology


  /**
     * molecule type of the nucleotide sequence
     * @see meta::nsdb
     */
  public String getMoleculeType ()
  {
            org.omg.CORBA.portable.InputStream $in = null;
            try {
                org.omg.CORBA.portable.OutputStream $out = _request ("getMoleculeType", true);
                $in = _invoke ($out);
                String $result = $in.read_string ();
                return $result;
            } catch (org.omg.CORBA.portable.ApplicationException $ex) {
                $in = $ex.getInputStream ();
                String _id = $ex.getId ();
                throw new org.omg.CORBA.MARSHAL (_id);
            } catch (org.omg.CORBA.portable.RemarshalException $rm) {
                return getMoleculeType (        );
            } finally {
                _releaseReply ($in);
            }
  } // getMoleculeType


  /**
     * retrieve sequence of NucFeatureList associated with
     * the nucleotide sequence.
     * A sequence has <I>ownership</I> of all these 
     * features. It is possible on the other hand that
     * features, owned by another sequence, reference 
     * the current sequence. Currently there is no way to find out.
     * @raises type::NoResult if no features are owned by the sequence
     */
  public nsdb.NucFeature[] getNucFeatures () throws type.NoResult
  {
            org.omg.CORBA.portable.InputStream $in = null;
            try {
                org.omg.CORBA.portable.OutputStream $out = _request ("getNucFeatures", true);
                $in = _invoke ($out);
                nsdb.NucFeature $result[] = nsdb.NucFeatureListHelper.read ($in);
                return $result;
            } catch (org.omg.CORBA.portable.ApplicationException $ex) {
                $in = $ex.getInputStream ();
                String _id = $ex.getId ();
                if (_id.equals ("IDL:type/NoResult:1.0"))
                    throw type.NoResultHelper.read ($in);
                else
                    throw new org.omg.CORBA.MARSHAL (_id);
            } catch (org.omg.CORBA.portable.RemarshalException $rm) {
                return getNucFeatures (        );
            } finally {
                _releaseReply ($in);
            }
  } // getNucFeatures


  /**
     * A location of a NucFeature can span multiple sequences.
     * If only the location of a feature relevant to the current
     * sequence is required, this method will calculate that.
     * @parm nuc_feature Feature from which location needs to be
     *   intersected with the current sequence.
     * @raises type::InvalidRelation if the nuc_feature 
     *   is not associated to the current sequence
     */
  public nsdb.Location getLocalLocation (nsdb.NucFeature nuc_feature) throws type.InvalidRelation
  {
            org.omg.CORBA.portable.InputStream $in = null;
            try {
                org.omg.CORBA.portable.OutputStream $out = _request ("getLocalLocation", true);
                nsdb.NucFeatureHelper.write ($out, nuc_feature);
                $in = _invoke ($out);
                nsdb.Location $result = nsdb.LocationHelper.read ($in);
                return $result;
            } catch (org.omg.CORBA.portable.ApplicationException $ex) {
                $in = $ex.getInputStream ();
                String _id = $ex.getId ();
                if (_id.equals ("IDL:type/InvalidRelation:1.0"))
                    throw type.InvalidRelationHelper.read ($in);
                else
                    throw new org.omg.CORBA.MARSHAL (_id);
            } catch (org.omg.CORBA.portable.RemarshalException $rm) {
                return getLocalLocation (nuc_feature        );
            } finally {
                _releaseReply ($in);
            }
  } // getLocalLocation


  /**
     * organism(s) from which the NucSeq was obtained.
     * If the sequence is chimeric, multiple organisms will be returned.
     * For each organism, there should be a source feature associated
     * with the current sequence. This source feature has a location
     * defining which part of the sequence was derived from the specified
     * organism.
     * This method provides a shortcut to:
     * invoke getNucFeaturesByKey("source"), invoke getQualifiers() on each 
     * source feature and loop through qualifiers to find DbXref. 
     * @raises type::NoResult if no source features are associated with
     * the sequence (should never happen).
     */
  public type.DbXref[] getOrganisms () throws type.NoResult
  {
            org.omg.CORBA.portable.InputStream $in = null;
            try {
                org.omg.CORBA.portable.OutputStream $out = _request ("getOrganisms", true);
                $in = _invoke ($out);
                type.DbXref $result[] = type.DbXrefListHelper.read ($in);
                return $result;
            } catch (org.omg.CORBA.portable.ApplicationException $ex) {
                $in = $ex.getInputStream ();
                String _id = $ex.getId ();
                if (_id.equals ("IDL:type/NoResult:1.0"))
                    throw type.NoResultHelper.read ($in);
                else
                    throw new org.omg.CORBA.MARSHAL (_id);
            } catch (org.omg.CORBA.portable.RemarshalException $rm) {
                return getOrganisms (        );
            } finally {
                _releaseReply ($in);
            }
  } // getOrganisms


  /**
     * retreive all features of a specific kind (FeatureKey)
     * @parm key Type of features to be retrieved
     * @raises type::NoResult if the sequence has no associated features
     *     of the requested type.
     * @raises type::InvalidArgumentValue if the key is not a 
     * <A href="http://www.ebi.ac.uk/ebi_docs/embl_db/ft/feature_table.html">
     * valid feature key</A>
     * @see NucFeature
     */
  public nsdb.NucFeature[] getNucFeaturesByKey (String key) throws type.NoResult, type.InvalidArgumentValue
  {
            org.omg.CORBA.portable.InputStream $in = null;
            try {
                org.omg.CORBA.portable.OutputStream $out = _request ("getNucFeaturesByKey", true);
                $out.write_string (key);
                $in = _invoke ($out);
                nsdb.NucFeature $result[] = nsdb.NucFeatureListHelper.read ($in);
                return $result;
            } catch (org.omg.CORBA.portable.ApplicationException $ex) {
                $in = $ex.getInputStream ();
                String _id = $ex.getId ();
                if (_id.equals ("IDL:type/NoResult:1.0"))
                    throw type.NoResultHelper.read ($in);
                else if (_id.equals ("IDL:type/InvalidArgumentValue:1.0"))
                    throw type.InvalidArgumentValueHelper.read ($in);
                else
                    throw new org.omg.CORBA.MARSHAL (_id);
            } catch (org.omg.CORBA.portable.RemarshalException $rm) {
                return getNucFeaturesByKey (key        );
            } finally {
                _releaseReply ($in);
            }
  } // getNucFeaturesByKey


  /**
     * Create nucleotide sequence of the segment specified
     * The first base in the sequence is numbered 1
     *
     * @parm start first base of sub-sequence (inclusive)
     * @parm end last base of sub-sequence (inclusive)
     * @raises type::IndexOutOfRange if start &lt 1
     *   or end &gt length
     */
  public String getSubSeq (int start, int end) throws type.IndexOutOfRange
  {
            org.omg.CORBA.portable.InputStream $in = null;
            try {
                org.omg.CORBA.portable.OutputStream $out = _request ("getSubSeq", true);
                $out.write_ulong (start);
                $out.write_ulong (end);
                $in = _invoke ($out);
                String $result = $in.read_string ();
                return $result;
            } catch (org.omg.CORBA.portable.ApplicationException $ex) {
                $in = $ex.getInputStream ();
                String _id = $ex.getId ();
                if (_id.equals ("IDL:type/IndexOutOfRange:1.0"))
                    throw type.IndexOutOfRangeHelper.read ($in);
                else
                    throw new org.omg.CORBA.MARSHAL (_id);
            } catch (org.omg.CORBA.portable.RemarshalException $rm) {
                return getSubSeq (start, end        );
            } finally {
                _releaseReply ($in);
            }
  } // getSubSeq


  /** 
      * Create nucleotide sequence of the location derived from the specified feature
      * and contained in the current NucSeq.
      * @raises type::InvalidRelation if the nuc_feature 
      *   is not associated to the current sequence
            * @raises InexactLocation if an exact sequence cannot be
      *   determined due to the feature's location being inexact
      */
  public String getSubSeqByFeature (nsdb.NucFeature feature) throws type.InvalidRelation, nsdb.InexactLocation
  {
            org.omg.CORBA.portable.InputStream $in = null;
            try {
                org.omg.CORBA.portable.OutputStream $out = _request ("getSubSeqByFeature", true);
                nsdb.NucFeatureHelper.write ($out, feature);
                $in = _invoke ($out);
                String $result = $in.read_string ();
                return $result;
            } catch (org.omg.CORBA.portable.ApplicationException $ex) {
                $in = $ex.getInputStream ();
                String _id = $ex.getId ();
                if (_id.equals ("IDL:type/InvalidRelation:1.0"))
                    throw type.InvalidRelationHelper.read ($in);
                else if (_id.equals ("IDL:nsdb/InexactLocation:1.0"))
                    throw nsdb.InexactLocationHelper.read ($in);
                else
                    throw new org.omg.CORBA.MARSHAL (_id);
            } catch (org.omg.CORBA.portable.RemarshalException $rm) {
                return getSubSeqByFeature (feature        );
            } finally {
                _releaseReply ($in);
            }
  } // getSubSeqByFeature


  /**
             * @raises type::InvalidRelation if reference does not exist
             * @raises type::InvalidRelation if reference is not 
             *   associated to the current sequence
             * @raises type::NoResult if there is no location associated with this reference
             */
  public nsdb.Location getReferenceLocation (String reference_id) throws type.InvalidRelation, type.NoResult
  {
            org.omg.CORBA.portable.InputStream $in = null;
            try {
                org.omg.CORBA.portable.OutputStream $out = _request ("getReferenceLocation", true);
                $out.write_string (reference_id);
                $in = _invoke ($out);
                nsdb.Location $result = nsdb.LocationHelper.read ($in);
                return $result;
            } catch (org.omg.CORBA.portable.ApplicationException $ex) {
                $in = $ex.getInputStream ();
                String _id = $ex.getId ();
                if (_id.equals ("IDL:type/InvalidRelation:1.0"))
                    throw type.InvalidRelationHelper.read ($in);
                else if (_id.equals ("IDL:type/NoResult:1.0"))
                    throw type.NoResultHelper.read ($in);
                else
                    throw new org.omg.CORBA.MARSHAL (_id);
            } catch (org.omg.CORBA.portable.RemarshalException $rm) {
                return getReferenceLocation (reference_id        );
            } finally {
                _releaseReply ($in);
            }
  } // getReferenceLocation


  /**
     * retrieve unique identifier
     */
  public String getBioSeqId ()
  {
            org.omg.CORBA.portable.InputStream $in = null;
            try {
                org.omg.CORBA.portable.OutputStream $out = _request ("getBioSeqId", true);
                $in = _invoke ($out);
                String $result = $in.read_string ();
                return $result;
            } catch (org.omg.CORBA.portable.ApplicationException $ex) {
                $in = $ex.getInputStream ();
                String _id = $ex.getId ();
                throw new org.omg.CORBA.MARSHAL (_id);
            } catch (org.omg.CORBA.portable.RemarshalException $rm) {
                return getBioSeqId (        );
            } finally {
                _releaseReply ($in);
            }
  } // getBioSeqId


  /**
     * length (nr of elements) of the biosequence
     */
  public int getLength ()
  {
            org.omg.CORBA.portable.InputStream $in = null;
            try {
                org.omg.CORBA.portable.OutputStream $out = _request ("getLength", true);
                $in = _invoke ($out);
                int $result = $in.read_ulong ();
                return $result;
            } catch (org.omg.CORBA.portable.ApplicationException $ex) {
                $in = $ex.getInputStream ();
                String _id = $ex.getId ();
                throw new org.omg.CORBA.MARSHAL (_id);
            } catch (org.omg.CORBA.portable.RemarshalException $rm) {
                return getLength (        );
            } finally {
                _releaseReply ($in);
            }
  } // getLength


  /**
     * sequence of objects describing the elements in the biosequence
     * This is a generic description. Most subclasses
     * will define more convenient methods for accessing the biosequence.
     * @returns any containing an set of objects. The any should have 
     *          a typecode tk_array.
     */
  public org.omg.CORBA.Any getAnySeq ()
  {
            org.omg.CORBA.portable.InputStream $in = null;
            try {
                org.omg.CORBA.portable.OutputStream $out = _request ("getAnySeq", true);
                $in = _invoke ($out);
                org.omg.CORBA.Any $result = $in.read_any ();
                return $result;
            } catch (org.omg.CORBA.portable.ApplicationException $ex) {
                $in = $ex.getInputStream ();
                String _id = $ex.getId ();
                throw new org.omg.CORBA.MARSHAL (_id);
            } catch (org.omg.CORBA.portable.RemarshalException $rm) {
                return getAnySeq (        );
            } finally {
                _releaseReply ($in);
            }
  } // getAnySeq


  /**
     * Return current version of the BioSeq. returns 0 if versioning is not
     * implemented on the bioseq.
     */
  public int getBioSeqVersion ()
  {
            org.omg.CORBA.portable.InputStream $in = null;
            try {
                org.omg.CORBA.portable.OutputStream $out = _request ("getBioSeqVersion", true);
                $in = _invoke ($out);
                int $result = $in.read_ulong ();
                return $result;
            } catch (org.omg.CORBA.portable.ApplicationException $ex) {
                $in = $ex.getInputStream ();
                String _id = $ex.getId ();
                throw new org.omg.CORBA.MARSHAL (_id);
            } catch (org.omg.CORBA.portable.RemarshalException $rm) {
                return getBioSeqVersion (        );
            } finally {
                _releaseReply ($in);
            }
  } // getBioSeqVersion


  /**
     * short (one line) description
     */
  public String getDescription () throws type.NoResult
  {
            org.omg.CORBA.portable.InputStream $in = null;
            try {
                org.omg.CORBA.portable.OutputStream $out = _request ("getDescription", true);
                $in = _invoke ($out);
                String $result = $in.read_string ();
                return $result;
            } catch (org.omg.CORBA.portable.ApplicationException $ex) {
                $in = $ex.getInputStream ();
                String _id = $ex.getId ();
                if (_id.equals ("IDL:type/NoResult:1.0"))
                    throw type.NoResultHelper.read ($in);
                else
                    throw new org.omg.CORBA.MARSHAL (_id);
            } catch (org.omg.CORBA.portable.RemarshalException $rm) {
                return getDescription (        );
            } finally {
                _releaseReply ($in);
            }
  } // getDescription


  /**
     * sequence of keywords, describing the characteristics of the sequence
     */
  public String[] getKeywords () throws type.NoResult
  {
            org.omg.CORBA.portable.InputStream $in = null;
            try {
                org.omg.CORBA.portable.OutputStream $out = _request ("getKeywords", true);
                $in = _invoke ($out);
                String $result[] = type.stringListHelper.read ($in);
                return $result;
            } catch (org.omg.CORBA.portable.ApplicationException $ex) {
                $in = $ex.getInputStream ();
                String _id = $ex.getId ();
                if (_id.equals ("IDL:type/NoResult:1.0"))
                    throw type.NoResultHelper.read ($in);
                else
                    throw new org.omg.CORBA.MARSHAL (_id);
            } catch (org.omg.CORBA.portable.RemarshalException $rm) {
                return getKeywords (        );
            } finally {
                _releaseReply ($in);
            }
  } // getKeywords


  /**
     * sequence of comments, describing the characteristics of the sequence
     */
  public String[] getComments () throws type.NoResult
  {
            org.omg.CORBA.portable.InputStream $in = null;
            try {
                org.omg.CORBA.portable.OutputStream $out = _request ("getComments", true);
                $in = _invoke ($out);
                String $result[] = type.stringListHelper.read ($in);
                return $result;
            } catch (org.omg.CORBA.portable.ApplicationException $ex) {
                $in = $ex.getInputStream ();
                String _id = $ex.getId ();
                if (_id.equals ("IDL:type/NoResult:1.0"))
                    throw type.NoResultHelper.read ($in);
                else
                    throw new org.omg.CORBA.MARSHAL (_id);
            } catch (org.omg.CORBA.portable.RemarshalException $rm) {
                return getComments (        );
            } finally {
                _releaseReply ($in);
            }
  } // getComments


  /**
     * cross references to other databases containing related or additional
     * information
     */
  public type.DbXref[] getDbXrefs () throws type.NoResult
  {
            org.omg.CORBA.portable.InputStream $in = null;
            try {
                org.omg.CORBA.portable.OutputStream $out = _request ("getDbXrefs", true);
                $in = _invoke ($out);
                type.DbXref $result[] = type.DbXrefListHelper.read ($in);
                return $result;
            } catch (org.omg.CORBA.portable.ApplicationException $ex) {
                $in = $ex.getInputStream ();
                String _id = $ex.getId ();
                if (_id.equals ("IDL:type/NoResult:1.0"))
                    throw type.NoResultHelper.read ($in);
                else
                    throw new org.omg.CORBA.MARSHAL (_id);
            } catch (org.omg.CORBA.portable.RemarshalException $rm) {
                return getDbXrefs (        );
            } finally {
                _releaseReply ($in);
            }
  } // getDbXrefs


  /**
     * cross references to the EMBL publication database
     * information
     */
  public type.DbXref[] getReferences () throws type.NoResult
  {
            org.omg.CORBA.portable.InputStream $in = null;
            try {
                org.omg.CORBA.portable.OutputStream $out = _request ("getReferences", true);
                $in = _invoke ($out);
                type.DbXref $result[] = type.DbXrefListHelper.read ($in);
                return $result;
            } catch (org.omg.CORBA.portable.ApplicationException $ex) {
                $in = $ex.getInputStream ();
                String _id = $ex.getId ();
                if (_id.equals ("IDL:type/NoResult:1.0"))
                    throw type.NoResultHelper.read ($in);
                else
                    throw new org.omg.CORBA.MARSHAL (_id);
            } catch (org.omg.CORBA.portable.RemarshalException $rm) {
                return getReferences (        );
            } finally {
                _releaseReply ($in);
            }
  } // getReferences


  /**
     * Retrieve entry indentifier. More information on the 
     * <A href="http://www.ebi.ac.uk/ebi_docs/embl_db/usrman/id_line.html">format</A> of
     * an entry name is available in the
     *  <A href="http://www.ebi.ac.uk/ebi_docs/embl_db/usrman/usrman.html">
     * EMBL User Manual</A>.
     */
  public String getEntryName ()
  {
            org.omg.CORBA.portable.InputStream $in = null;
            try {
                org.omg.CORBA.portable.OutputStream $out = _request ("getEntryName", true);
                $in = _invoke ($out);
                String $result = $in.read_string ();
                return $result;
            } catch (org.omg.CORBA.portable.ApplicationException $ex) {
                $in = $ex.getInputStream ();
                String _id = $ex.getId ();
                throw new org.omg.CORBA.MARSHAL (_id);
            } catch (org.omg.CORBA.portable.RemarshalException $rm) {
                return getEntryName (        );
            } finally {
                _releaseReply ($in);
            }
  } // getEntryName


  /**
     * The entry version defines the current version of an EMBL Sequence Database
     * Entry. I.e. the complete set information related to a particular sequence.
     * The Entry version is incremented whenever anything changes in the sequence or it's 
     * associated information.
     */
  public int getEntryVersion ()
  {
            org.omg.CORBA.portable.InputStream $in = null;
            try {
                org.omg.CORBA.portable.OutputStream $out = _request ("getEntryVersion", true);
                $in = _invoke ($out);
                int $result = $in.read_ulong ();
                return $result;
            } catch (org.omg.CORBA.portable.ApplicationException $ex) {
                $in = $ex.getInputStream ();
                String _id = $ex.getId ();
                throw new org.omg.CORBA.MARSHAL (_id);
            } catch (org.omg.CORBA.portable.RemarshalException $rm) {
                return getEntryVersion (        );
            } finally {
                _releaseReply ($in);
            }
  } // getEntryVersion


  /**
     * Get entry status code.
     * @see meta::nsdb
     */
  public String getEntryStatus ()
  {
            org.omg.CORBA.portable.InputStream $in = null;
            try {
                org.omg.CORBA.portable.OutputStream $out = _request ("getEntryStatus", true);
                $in = _invoke ($out);
                String $result = $in.read_string ();
                return $result;
            } catch (org.omg.CORBA.portable.ApplicationException $ex) {
                $in = $ex.getInputStream ();
                String _id = $ex.getId ();
                throw new org.omg.CORBA.MARSHAL (_id);
            } catch (org.omg.CORBA.portable.RemarshalException $rm) {
                return getEntryStatus (        );
            } finally {
                _releaseReply ($in);
            }
  } // getEntryStatus


  /**
     * Sequence of revisions when Entry was created/changed.
     */
  public type.Revision[] getRevisions ()
  {
            org.omg.CORBA.portable.InputStream $in = null;
            try {
                org.omg.CORBA.portable.OutputStream $out = _request ("getRevisions", true);
                $in = _invoke ($out);
                type.Revision $result[] = type.RevisionListHelper.read ($in);
                return $result;
            } catch (org.omg.CORBA.portable.ApplicationException $ex) {
                $in = $ex.getInputStream ();
                String _id = $ex.getId ();
                throw new org.omg.CORBA.MARSHAL (_id);
            } catch (org.omg.CORBA.portable.RemarshalException $rm) {
                return getRevisions (        );
            } finally {
                _releaseReply ($in);
            }
  } // getRevisions


  /**
     * List of secondary accession numbers. I.e. accession numbers
     * of deprecated entries, now merged into the current entry or
     * split over multiple entries, as decribed in the 
     * <A href="http://www.ebi.ac.uk/ebi_docs/embl_db/usrman/ac_line.html">
     * AC line</A> documentation in the User manual.
     */
  public String[] getSecondaryIds ()
  {
            org.omg.CORBA.portable.InputStream $in = null;
            try {
                org.omg.CORBA.portable.OutputStream $out = _request ("getSecondaryIds", true);
                $in = _invoke ($out);
                String $result[] = type.stringListHelper.read ($in);
                return $result;
            } catch (org.omg.CORBA.portable.ApplicationException $ex) {
                $in = $ex.getInputStream ();
                String _id = $ex.getId ();
                throw new org.omg.CORBA.MARSHAL (_id);
            } catch (org.omg.CORBA.portable.RemarshalException $rm) {
                return getSecondaryIds (        );
            } finally {
                _releaseReply ($in);
            }
  } // getSecondaryIds


  /**
           * number of adenine
           */
  public int getCountA ()
  {
            org.omg.CORBA.portable.InputStream $in = null;
            try {
                org.omg.CORBA.portable.OutputStream $out = _request ("getCountA", true);
                $in = _invoke ($out);
                int $result = $in.read_ulong ();
                return $result;
            } catch (org.omg.CORBA.portable.ApplicationException $ex) {
                $in = $ex.getInputStream ();
                String _id = $ex.getId ();
                throw new org.omg.CORBA.MARSHAL (_id);
            } catch (org.omg.CORBA.portable.RemarshalException $rm) {
                return getCountA (        );
            } finally {
                _releaseReply ($in);
            }
  } // getCountA


  /**
           * number of cytosine
           */
  public int getCountC ()
  {
            org.omg.CORBA.portable.InputStream $in = null;
            try {
                org.omg.CORBA.portable.OutputStream $out = _request ("getCountC", true);
                $in = _invoke ($out);
                int $result = $in.read_ulong ();
                return $result;
            } catch (org.omg.CORBA.portable.ApplicationException $ex) {
                $in = $ex.getInputStream ();
                String _id = $ex.getId ();
                throw new org.omg.CORBA.MARSHAL (_id);
            } catch (org.omg.CORBA.portable.RemarshalException $rm) {
                return getCountC (        );
            } finally {
                _releaseReply ($in);
            }
  } // getCountC


  /**
           * number of guanine 
           */
  public int getCountG ()
  {
            org.omg.CORBA.portable.InputStream $in = null;
            try {
                org.omg.CORBA.portable.OutputStream $out = _request ("getCountG", true);
                $in = _invoke ($out);
                int $result = $in.read_ulong ();
                return $result;
            } catch (org.omg.CORBA.portable.ApplicationException $ex) {
                $in = $ex.getInputStream ();
                String _id = $ex.getId ();
                throw new org.omg.CORBA.MARSHAL (_id);
            } catch (org.omg.CORBA.portable.RemarshalException $rm) {
                return getCountG (        );
            } finally {
                _releaseReply ($in);
            }
  } // getCountG


  /**
           * number of thymine (in DNA sequence)
           *    or
           * number of uracil (in RNA sequence)
           */
  public int getCountT ()
  {
            org.omg.CORBA.portable.InputStream $in = null;
            try {
                org.omg.CORBA.portable.OutputStream $out = _request ("getCountT", true);
                $in = _invoke ($out);
                int $result = $in.read_ulong ();
                return $result;
            } catch (org.omg.CORBA.portable.ApplicationException $ex) {
                $in = $ex.getInputStream ();
                String _id = $ex.getId ();
                throw new org.omg.CORBA.MARSHAL (_id);
            } catch (org.omg.CORBA.portable.RemarshalException $rm) {
                return getCountT (        );
            } finally {
                _releaseReply ($in);
            }
  } // getCountT

  // Type-specific CORBA::Object operations
  private static String[] __ids = {
    "IDL:nsdb/EmblSeqWriter:1.0", 
    "IDL:nsdb/EmblSeq:1.0", 
    "IDL:nsdb/NucSeq:1.0", 
    "IDL:seqdb/BioSeq:1.0", 
    "IDL:seqdb/SeqInfo:1.0", 
    "IDL:nsdb/EntryInfo:1.0"};

  public String[] _ids ()
  {
    return (String[])__ids.clone ();
  }

  private void readObject (java.io.ObjectInputStream s) throws java.io.IOException
  {
     String str = s.readUTF ();
     String[] args = null;
     java.util.Properties props = null;
     org.omg.CORBA.Object obj = org.omg.CORBA.ORB.init (args, props).string_to_object (str);
     org.omg.CORBA.portable.Delegate delegate = ((org.omg.CORBA.portable.ObjectImpl) obj)._get_delegate ();
     _set_delegate (delegate);
  }

  private void writeObject (java.io.ObjectOutputStream s) throws java.io.IOException
  {
     String[] args = null;
     java.util.Properties props = null;
     String str = org.omg.CORBA.ORB.init (args, props).object_to_string (this);
     s.writeUTF (str);
  }
} // class _EmblSeqWriterStub
